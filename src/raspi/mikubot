# pico_miku_display_framebuf.py
import network
import socket
import json
import time
from machine import Pin, I2C, Timer
import ssd1306
import framebuf

# WiFi Config
WIFI_SSID = "Borotan on ig"
WIFI_PASSWORD = "dfm281017"

# OLED Setup (128x64 display)
i2c = I2C(0, scl=Pin(1), sda=Pin(0))
oled = ssd1306.SSD1306_I2C(128, 64, i2c)

# Miku sprite (64x64 pixels as bytearray)
# Format: MONO_HLSB (Horizontal, 1 bit per pixel, LSB first)
# 64px width ร 64px height รท 8 bits per byte = 512 bytes
MIKU_SPRITE = bytearray([
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0xf0, 0x0f, 0xcf, 0xff, 0xff, 
0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xfc, 0x00, 0x0f, 0xf0, 0x00, 0x3f, 0xff, 
0xff, 0xf3, 0x00, 0xff, 0xff, 0x00, 0xcf, 0xff, 0xff, 0xe7, 0x00, 0xff, 0xff, 0x80, 0xe7, 0xff, 
0xff, 0xee, 0x03, 0xff, 0xff, 0xc0, 0x37, 0xff, 0xff, 0xee, 0x07, 0x8f, 0xff, 0xe0, 0x77, 0xff, 
0xff, 0xce, 0x07, 0x8f, 0xff, 0xe0, 0x73, 0xff, 0xff, 0xce, 0x07, 0x7f, 0xf8, 0xe0, 0x73, 0xff, 
0xff, 0xce, 0x04, 0xff, 0xfe, 0x70, 0x73, 0xff, 0xff, 0xce, 0x09, 0xff, 0xff, 0x30, 0x73, 0xff, 
0xff, 0xce, 0x0b, 0xfb, 0xff, 0x90, 0x73, 0xff, 0xff, 0xde, 0x1b, 0xfb, 0xff, 0x98, 0x7b, 0xff, 
0xff, 0xde, 0x13, 0xe3, 0xff, 0xd8, 0x7b, 0xff, 0xff, 0x9e, 0x17, 0xcb, 0xdf, 0xe8, 0x79, 0xff, 
0xff, 0x1f, 0x17, 0xbb, 0xcf, 0xe8, 0xf8, 0xff, 0xff, 0x1c, 0x37, 0x7b, 0xbb, 0xec, 0x3c, 0xff, 
0xff, 0x18, 0x37, 0x7b, 0xb9, 0xec, 0x1c, 0xff, 0xff, 0x10, 0x37, 0x7d, 0xbe, 0xec, 0x0c, 0xff, 
0xfe, 0x30, 0x30, 0x1d, 0xb8, 0x2c, 0x0e, 0x7f, 0xfe, 0x70, 0x30, 0x0c, 0x30, 0x0c, 0x0e, 0x7f, 
0xfe, 0x70, 0x30, 0x04, 0x30, 0x0c, 0x0e, 0x7f, 0xfc, 0xf0, 0x33, 0x06, 0x30, 0xcc, 0x0f, 0x3f, 
0xfc, 0xf0, 0x33, 0x06, 0x30, 0xcc, 0x0f, 0x3f, 0xf9, 0xf0, 0x13, 0xc7, 0xa3, 0xc8, 0x0f, 0x9f, 
0xf9, 0xf0, 0x13, 0xcf, 0xf3, 0xc8, 0x0f, 0xdf, 0xfb, 0xf8, 0x14, 0x9f, 0xf9, 0x28, 0x0f, 0xdf, 
0xfb, 0xf8, 0x03, 0xff, 0xff, 0xc0, 0x0f, 0xdf, 0xe7, 0xf9, 0xe1, 0xff, 0xff, 0x87, 0x9f, 0xe7, 
0xe7, 0xf9, 0xf0, 0xff, 0xff, 0x0f, 0xdf, 0xe7, 0xe7, 0xfb, 0xf1, 0xff, 0xff, 0x8f, 0xdf, 0xe7, 
0xe7, 0xfb, 0xff, 0xe0, 0x07, 0xff, 0xdf, 0xe7, 0xe7, 0xfb, 0xff, 0xb9, 0x9d, 0xff, 0xdf, 0xe7, 
0xcf, 0xfc, 0xff, 0xb4, 0x2d, 0xff, 0x3f, 0xf3, 0xcf, 0xfc, 0xff, 0xf1, 0x8f, 0xff, 0x3f, 0xf3, 
0xcf, 0xfc, 0xff, 0x61, 0x86, 0xff, 0x3f, 0xf3, 0xcf, 0xfc, 0xff, 0x01, 0x80, 0xff, 0x3f, 0xf3, 
0xcf, 0xfc, 0xfe, 0x03, 0xc0, 0x7f, 0x3f, 0xf3, 0xcf, 0xfe, 0xfc, 0x01, 0x80, 0x3f, 0x7f, 0xf3, 
0xcf, 0xfe, 0x78, 0x00, 0x00, 0x1e, 0x7f, 0xf3, 0xcf, 0xfe, 0x7c, 0x00, 0x00, 0x3e, 0x7f, 0xf3, 
0xcf, 0xfe, 0x7e, 0x06, 0x60, 0x7e, 0x6f, 0xf3, 0xcf, 0xf9, 0x3f, 0x00, 0x00, 0xfc, 0x8f, 0xf3, 
0xcf, 0xf8, 0x3f, 0x00, 0x00, 0xfc, 0x0f, 0xf3, 0xcf, 0xf8, 0x3f, 0x8c, 0x31, 0xfc, 0x0f, 0xf3, 
0xcf, 0xf9, 0x3f, 0xbd, 0xbd, 0xfc, 0x8f, 0xf3, 0xcf, 0xf9, 0x3f, 0xbe, 0x7d, 0xfc, 0x8f, 0xf3, 
0xcf, 0xf9, 0xbf, 0xbf, 0x7d, 0xfd, 0x8f, 0xf3, 0xe7, 0xf9, 0xff, 0xbe, 0x7d, 0xff, 0x8f, 0xe7, 
0xe7, 0xf9, 0xff, 0x80, 0x01, 0xff, 0x8f, 0xe7, 0xe7, 0xf9, 0xff, 0x80, 0x01, 0xff, 0x8f, 0xe7, 
0xf8, 0x1c, 0xff, 0xc4, 0x23, 0xff, 0x3c, 0x1f, 0xfc, 0x1c, 0xff, 0xc0, 0x03, 0xff, 0x38, 0x3f, 
0xfc, 0x00, 0xff, 0xc0, 0x03, 0xff, 0x00, 0x3f, 0xff, 0xe0, 0xff, 0xc0, 0x03, 0xff, 0x07, 0xff, 
0xff, 0xff, 0xff, 0xc0, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x03, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xe0, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x0f, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xf8, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
])

class MikuDisplay:
    def __init__(self):
        self.current_text = ""
        self.lines = []
        self.scroll_position = 0
        self.scroll_timer = Timer()
        self.miku_buf = framebuf.FrameBuffer(MIKU_SPRITE, 64, 64, framebuf.MONO_HLSB)
        
    def show_miku(self):
        """Display Miku sprite on left half using FrameBuffer"""
        oled.fill(0)
        oled.blit(self.miku_buf, 0, 0)  # Draw at (0,0)
        oled.show()
    
    def wrap_text(self, text, max_chars=10):
        """Wrap text to fit in the 64px wide area"""
        words = text.split(' ')
        lines = []
        current_line = ""
        
        for word in words:
            if len(current_line) + len(word) + 1 <= max_chars:
                current_line += " " + word if current_line else word
            else:
                lines.append(current_line)
                current_line = word
        
        if current_line:
            lines.append(current_line)
        
        return lines
    
    def display(self, text):
        """Display text on right half while keeping Miku visible"""
        self.current_text = text
        self.lines = self.wrap_text(text)
        self.scroll_position = 0
        self.scroll_timer.deinit()
        self._update_display()
        
        if len(self.lines) > 6:  # Only scroll if more than 6 lines
            self.scroll_timer.init(period=350, mode=Timer.PERIODIC, callback=self._scroll_text)
    
    def _update_display(self):
        """Update only the text area (right 64x64)"""
        # Clear just the text area
        oled.fill_rect(64, 0, 64, 64, 0)
        
        # Draw visible lines
        visible_lines = self.lines[self.scroll_position:self.scroll_position+6]
        for i, line in enumerate(visible_lines):
            oled.text(line, 64, i * 10)  # 10px per line
        
        oled.show()
    
    def _scroll_text(self, timer):
        """Auto-scroll callback"""
        if len(self.lines) > 6:
            max_scroll = len(self.lines) - 6
            self.scroll_position = (self.scroll_position + 1) % (max_scroll + 1)
            self._update_display()

def start_server():
    display = MikuDisplay()
    display.show_miku()  # Show Miku immediately
    display.display("Connecting...")
    
    # WiFi connection
    wlan = network.WLAN(network.STA_IF)
    wlan.active(True)
    wlan.connect(WIFI_SSID, WIFI_PASSWORD)
    
    while not wlan.isconnected():
        time.sleep(1)
    
    ip = wlan.ifconfig()[0]
    display.display(f"Connected!\nIP: {ip}")
    
    # Socket server
    s = socket.socket()
    s.bind((ip, 5005))
    s.listen(1)
    
    while True:
        try:
            conn, addr = s.accept()
            data = conn.recv(1024).decode().strip()
            
            try:
                msg = json.loads(data)
                if "text" in msg:
                    display.display(msg["text"])
            except:
                display.display("Invalid message")
            
            conn.close()
        except Exception as e:
            print("Error:", e)
            time.sleep(1)

start_server()
